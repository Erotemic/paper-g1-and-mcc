import Mathlib.Tactic

noncomputable section

/-- Precision / PPV = TP / (TP + FP) -/
def PPV (TP FP : ‚Ñù) : ‚Ñù :=
  TP / (TP + FP)

/-- Recall / TPR = TP / (TP + FN) -/
def TPR (TP FN : ‚Ñù) : ‚Ñù :=
  TP / (TP + FN)

/-- Fowlkes‚ÄìMallows index: geometric mean of precision and recall. -/
def FM (TP FP FN : ‚Ñù) : ‚Ñù :=
  Real.sqrt (PPV TP FP * TPR TP FN)

/-- Matthews Correlation Coefficient (MCC). We treat all entries as reals. -/
def MCC (TP TN FP FN : ‚Ñù) : ‚Ñù :=
  let num := TP * TN - FP * FN
  let den := Real.sqrt ((TP + FP) * (TP + FN) * (TN + FP) * (TN + FN))
  num / den

end

open Filter Topology

/--

This proof was generated by Aristotle AI https://aristotle.harmonic.fun/

https://leanprover.zulipchat.com/#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Can.20this.20GPT.205.2E1.20be.20simplified.3F/with/561031593

Main target theorem:

    lim_{TN‚Üí‚àû} MCC(TP,TN,FP,FN) = FM(TP,FP,FN)

  under non-degeneracy and `0 ‚â§ TP`.

  The definition of the main theroem (given in full later) is written as:
-/
theorem tendsto_MCC_atTop_eq_FM
    {TP FP FN : ‚Ñù}
    (hTPFPpos : 0 < TP + FP)
    (hTPFNpos : 0 < TP + FN)
    (hTP_nonneg : 0 ‚â§ TP)
    (hFP_nonneg : 0 ‚â§ FP)
    (hFN_nonneg : 0 ‚â§ FN) :
    Tendsto (fun TN : ‚Ñù => MCC TP TN FP FN) atTop (ùìù (FM TP FP FN)) := by
  -- Simplify the expression for the MCC as TN approaches infinity.
  have h_simplify : Filter.Tendsto (fun TN : ‚Ñù => (TP * TN - FP * FN) / Real.sqrt ((TP + FP) * (TP + FN) * (TN + FP) * (TN + FN))) Filter.atTop (ùìù (TP / Real.sqrt ((TP + FP) * (TP + FN)))) := by
    -- We divide numerator and denominator by $TN$:
    suffices h_suff'' : Filter.Tendsto (fun TN : ‚Ñù => (TP - FP * FN / TN) / Real.sqrt ((TP + FP) * (TP + FN) * (1 + FP / TN) * (1 + FN / TN))) Filter.atTop (ùìù (TP / Real.sqrt ((TP + FP) * (TP + FN)))) by
      -- By simplifying, we can see that the two expressions are equivalent for large TN.
      have h_eq : ‚àÄ TN : ‚Ñù, TN > 0 ‚Üí (TP * TN - FP * FN) / Real.sqrt ((TP + FP) * (TP + FN) * (TN + FP) * (TN + FN)) = (TP - FP * FN / TN) / Real.sqrt ((TP + FP) * (TP + FN) * (1 + FP / TN) * (1 + FN / TN)) := by
        intro TN hTNpos
        field_simp [hTNpos];
        rw [ Real.sqrt_div ( by positivity ), Real.sqrt_sq hTNpos.le ] ; ring;
        -- By simplifying, we can see that the two expressions are equal.
        field_simp [hTNpos]
        ring;
      exact h_suff''.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with TN hTN using h_eq TN hTN ‚ñ∏ rfl );
    exact le_trans ( Filter.Tendsto.div ( tendsto_const_nhds.sub ( tendsto_const_nhds.div_atTop Filter.tendsto_id ) ) ( Filter.Tendsto.sqrt <| Filter.Tendsto.mul ( Filter.Tendsto.mul ( tendsto_const_nhds.mul <| tendsto_const_nhds ) <| tendsto_const_nhds.add <| tendsto_const_nhds.div_atTop Filter.tendsto_id ) <| tendsto_const_nhds.add <| tendsto_const_nhds.div_atTop Filter.tendsto_id ) <| ne_of_gt <| Real.sqrt_pos.mpr <| by positivity ) <| by norm_num;
  convert h_simplify using 1;
  unfold FM PPV TPR; ring;
  field_simp;
  rw [ Real.sqrt_div ( by positivity ), Real.sqrt_sq ( by positivity ) ] ; ring
